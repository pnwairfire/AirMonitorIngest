% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/addClustering.R
\name{addClustering}
\alias{addClustering}
\title{Add clustering information to a dataframe}
\usage{
addClustering(
  tbl,
  clusterDiameter = 1000,
  lonVar = "longitude",
  latVar = "latitude",
  maxClusters = 50,
  flagAndKeep = FALSE
)
}
\arguments{
\item{tbl}{Tibble with geolocation information (\emph{e.g.} created by
\code{wrcc_qualityControl()} or \code{airsis_qualityControl}).}

\item{clusterDiameter}{Diameter in meters used to determine the number of
clusters (see description).}

\item{lonVar}{Name of longitude variable in the incoming tibble.}

\item{latVar}{Name of the latitude variable in the incoming tibble.}

\item{maxClusters}{Maximum number of clusters to try.}

\item{flagAndKeep}{Logical specifying flagging, rather than removal, of bad
data during the QC process.}
}
\value{
Input tibble with additional columns: \code{clusterLon, clusterLat}.
}
\description{
Clustering is used to assign individual measurements to
deployment locations.

A \emph{temporary} monitor will be moved around from time to time, sometimes across the country
and sometimes across the street.  We need to assign unique identifiers to each
new "deployment" but not when the monitor is moved a short distance.

We use clustering to find an appropriate number of unique "deployments".
The sensitivity of this algorithm can be adjused with the clusterDiameter argument.

Standard \code{kmeans} clustering does not work well when clusters can have widely
differing numbers of members. A much better result is acheived with
the Partitioning Around Medoids method available in \code{cluster::pam()}.

The value of \code{clusterRadius} is compared with the output of
\code{cluster::pam(...)$clusinfo[,'av_diss']} to determine the number of clusters.
}
\references{
\href{https://working-with-data.mazamascience.com/2021/07/15/when-k-means-clustering-fails/}{When k-means clustering fails}
}
